* Service Binary Hijacking:
	* Manual:
		* Get-CimInstance: Get information on services using Get-CimInstance cmdlet.
			* Example command: Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$\_.State -like 'Running'}
			* Note Get-CimInstance may not work if you are on a bind shell. Use RDP.
		* icacls or Get-ACL: Get permissions on the service binary. This will determine how a binary can be modified using the current user's permissions.
		* Compile a malicious binary and try replacing the service binary. Restart service for the hijacked service to start.
		* The malicious binary can be anything like adding new user to admin group or reverse shells etc.
	* Automated service binary hijacking using Powersploit PowerUp.
		* Make sure to use execution bypass using: "powershell -ep Bypass"
		* Import the script using ". .\\PowerUp.ps1" provides cmdlets for service binary hijacking.
		* location on kali linux: /usr/share/windows-resources/powersploit/Privesc/PowerUp.ps1
		* Get-ModifiableServiceFile: Displays services the current user can modify, such as the service binary or configuration files
		* Install-ServiceBinary: Replace the service binary and, if there are sufficient permissions, restart it. The default behavior is to create a new local user called john with the password Password123!
		* For more information refer to [PowerUp](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1)
	* Note: Depending on situation, automated tools can give wrong outputs. Switch to manual techniques if necessary.
* Service DLL Hijacking: Replace a DLL used by the service binary. This is an option if the binary cannot be modified by the current user permissions.
	* DLL search order: Below is how DLL is located before it is loaded.
		* The directory from which the application loaded.
		* The system directory.
		* The 16-bit system directory.
		* The Windows directory. 
		* The current directory.
		* The directories that are listed in the PATH environment variable.
		* [Microsoft documentation](https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order)
	* Sysinternals Procmon: Process Monitor is an advanced monitoring tool for Windows that shows real-time file system, Registry and process/thread activity.
		* Set filter to process name is "\<insert binary name\>"
		* Look for "CreateFile" events with states "NAME NOT FOUND" which are events for file creation or file open.
		* Find which file path are being searched for the DLLs. It should follow the DLL search order mentioned before.
		* [Microsoft documentation](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon)
	* DLLmain entry point: An optional entry point of a DLL which is executed when a DLL is loaded or unloaded by a process or thread.
		* Refer to the [Microsoft documentation](https://learn.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library#the-dll-entry-point) and copy the code there. Make sure to include stdlib.h, windows.h headers.
		* Under switch case "DLL_PROCESS_ATTACH", add your code. Example: A system call to create a new user and to administrator group. This code will be executed when the DLL is loaded by the process.
		* Compile the DLL using x86_64-w64-mingw32-gcc using "--shared" flag on kali.
		* Place the DLL in the appropriate file path found using Sysinternals Procmon which you can place with your permissions. Make sure this malicious DLL is placed at a file path before or on the file path found using the DLL search order where the DLL would have been originally found and loaded.
* Unquoted Service Path:
	* If a service path is unquoted such as C:\\Program Files\\My Program\\My Service\\service.exe then below is the search order used to find the executed when the service is started:
		* C:\\Program.exe
		* C:\\Program Files\\My.exe
		* C:\\Program Files\\My Program\\My.exe
		* C:\\Program Files\\My Program\\My service\\service.exe
	* Since multiple file paths are searched, a malicious file can be placed on the earlier file paths to subvert original execution.
	* Enumerate services: Get-CimInstance -ClassName win32_service | Select Name,State,PathName
	* In cmd.exe use wmic to get services with unquoted paths much easier. Use findstr to remove any directories that the current user has no permissions for and paths with quotes: wmic service get name,pathname |  findstr /i /v "C:\\Windows\\\" | findstr /i /v """
	* Stop the service and place the malicious executable in one of the earlier file paths from the search order. Use icacls to determine if the current user has permission to write the executable on the file path.
	* Restart the service. The malicious executable should have been executed.
	* Automated way:
		* Use Powersploit powerup.
		* Import powerup in powershell with common code: ". .\\PowerUp.ps1"
		* Gets all unquoted services: Get-UnquotedService 
		* Write malicious service using: Write-ServiceBinary -Name '\<service name\>' -Path "\<hijack path\>"
		* Restart the service: Restart-Service